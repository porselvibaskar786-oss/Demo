name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"  # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas pytz

      - name: Run patching
        run: |
          python <<'PY'
          import os, time, requests, boto3, pytz
          from datetime import datetime

          # Env variables
          TZ_NAME = os.getenv("TZ", "Asia/Kolkata")
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          AWS_REGION = os.getenv("AWS_REGION")
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL") or ""
          
          ssm = boto3.client("ssm", region_name=AWS_REGION)

          # Embedded patch schedule
          patch_schedule = [
              {
                  "app_name": "AIT No 1",
                  "start_date": "02-09-2025 08:20:50",
                  "stop_date":  "02-09-2025 08:21:45",
                  "environment": "Production",
                  "owner": "Porselvi Baskar",
                  "health_url": "http://56.228.6.225:3000/health",
                  "instanceid": "i-04e570fd98fc66e83",
                  "command": "docker start f88643e26d64"
              },
              {
                  "app_name": "AIT No 2",
                  "start_date": "02-09-2025 08:23:40",
                  "stop_date":  "02-09-2025 08:24:45",
                  "environment": "Production",
                  "owner": "Porselvi Baskar",
                  "health_url": "http://56.228.6.225:3000/health",
                  "instanceid": "i-04e570fd98fc66e83",
                  "command": "docker start f88643e26d64"
              }
          ]

          tz = pytz.timezone(TZ_NAME)
          now = datetime.now(tz)

          # Helper to post Teams message
          def post_teams(msg, level="Info"):
              if not TEAMS_URL: return
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7" if level.lower()=="info" else "FF0000",
                  "summary": f"{level}: {msg}",
                  "sections": [{"activityTitle": f"**{level}**", "text": msg}],
              }
              try: requests.post(TEAMS_URL, json=payload, timeout=10)
              except: pass

          # SSM command
          def ssm_run(instance_id, command, timeout_s=120):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[command]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False}
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return out["Status"], out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return "TimedOut", "", "SSM command timeout"
              except Exception as e:
                  return "Error", "", str(e)

          # Health check via SSM
          def health_check(instance_id, url):
              shell = f'curl -sS -m 5 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              status, out, err = ssm_run(instance_id, shell)
              code = None
              if "HTTP_STATUS:" in out:
                  _, tail = out.rsplit("HTTP_STATUS:",1)
                  try: code = int(tail.strip())
                  except: code = None
              return code

          # Main loop
          for row in patch_schedule:
              if row["environment"] != TARGET_ENV: continue
              app = row["app_name"]
              iid = row["instanceid"]
              cmd = row["command"]
              url = row["health_url"]
              start = tz.localize(datetime.strptime(row["start_date"], "%d-%m-%Y %H:%M:%S"))
              stop  = tz.localize(datetime.strptime(row["stop_date"], "%d-%m-%Y %H:%M:%S"))

              if start <= now <= stop:
                  post_teams(f"ðŸ›‘ Patching window active for {app} on {iid}", "Info")
                  rc, out, err = ssm_run(iid, cmd)
                  post_teams(f"âœ… {app} patched (SSM RC={rc})", "Info")
                  if url:
                      code = health_check(iid, url)
                      if code == 200:
                          post_teams(f"ðŸ’š {app} is healthy after patching", "Info")
                      else:
                          post_teams(f"âš  {app} is UNHEALTHY after patching (HTTP {code})", "Alert")
              else:
                  post_teams(f"â± Outside patch window for {app}", "Info")
          PY
