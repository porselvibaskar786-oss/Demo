name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata

      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz

      - name: Create SSM patching script
        run: |
          cat > windowed_health_check_ssm.py <<'PY'
          import os, re, time
          from datetime import datetime
          import pandas as pd
          import requests, boto3, pytz

          CSV_PATH     = os.getenv("CSV_PATH", "schedule.csv")
          TARGET_ENV   = os.getenv("TARGET_ENV", "Production")
          TZ_NAME      = os.getenv("TZ", "Asia/Kolkata")
          AWS_REGION   = os.getenv("AWS_REGION")
          TEAMS_URL    = os.getenv("TEAMS_WEBHOOK_URL") or ""
          FALLBACK_IID = (os.getenv("EC2_INSTANCE_ID") or "").strip()

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(message: str, level: str = "Info", table: str = None):
              if not TEAMS_URL:
                  return
              sections = [{ "activityTitle": f"**{level}**", "text": message }]
              if table:
                  sections.append({ "text": table })
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7" if level.lower()=="info" else "FF0000",
                  "summary": f"{level}: {message}",
                  "sections": sections,
              }
              try:
                  requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e:
                  print(f"[teams] send failed: {e}")

          def norm(s: str) -> str:
              s = (s or "").strip().lower()
              s = re.sub(r"[^\w]+", "_", s)
              s = re.sub(r"_{2,}", "_", s).strip("_")
              return s

          ALIASES = {
              "app":        ["app", "app_name", "application"],
              "env":        ["environment", "env"],
              "start":      ["start", "start_date", "window_start"],
              "stop":       ["stop", "stop_date", "window_stop", "end"],
              "url":        ["health_url", "health", "url"],
              "cmd":        ["command", "cmd", "restart_command", "action"],
              "instanceid": ["instanceid", "instance_id", "ec2_instance_id"],
          }

          def first_nonempty(row: dict, names: list[str]) -> str:
              for n in names:
                  v = row.get(n, "")
                  if v is not None and str(v).strip() != "":
                      return str(v).strip()
              return ""

          def require(row: dict, field: str) -> str:
              v = first_nonempty(row, ALIASES[field])
              if not v:
                  raise ValueError(f"Missing required field: {field}")
              return v

          def parse_dt(s: str, tz):
              s = (s or "").strip()
              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):
                  try:
                      return tz.localize(datetime.strptime(s, fmt))
                  except:
                      pass
              raise ValueError(f"Bad date '{s}'")

          def load_rows(path: str):
              ext = os.path.splitext(path)[1].lower()
              if ext == ".csv":
                  df = pd.read_csv(path)
              elif ext in (".xlsx", ".xls"):
                  df = pd.read_excel(path)
              else:
                  raise ValueError("Input must be CSV or XLS/XLSX")
              df.columns = [norm(c) for c in df.columns]
              return df.to_dict("records")

          def ssm_run(instance_id: str, command: str, timeout_s: int = 180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands": [command]},
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          code = int(out.get("ResponseCode", 1))
                          return code, out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1, "", "Timed out waiting for SSM command"
              except Exception as e:
                  return 1, "", f"SSM error: {e}"

          def http_status_via_ssm(instance_id: str, url: str):
              if not url:
                  return None, "no url"
              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              code, out, err = ssm_run(instance_id, shell)
              if code != 0:
                  return None, err or out
              status = None
              if "HTTP_STATUS:" in out:
                  _, tail = out.rsplit("HTTP_STATUS:", 1)
                  try:
                      status = int(tail.strip())
                  except:
                      pass
              return status, out

          def ensure_online(instance_id: str) -> bool:
              try:
                  resp = ssm.describe_instance_information(
                      Filters=[{"Key":"InstanceIds","Values":[instance_id]}]
                  )
                  if resp["InstanceInformationList"]:
                      return resp["InstanceInformationList"][0]["PingStatus"] == "Online"
              except Exception as e:
                  print(f"[ssm] check failed: {e}")
              return False

          def make_table(app, iid, start, stop, url):
              return (
                  "| App | Instance | Start | End | Health URL |\n"
                  "|-----|----------|-------|-----|------------|\n"
                  f"| {app} | {iid} | {start.strftime('%d-%m-%Y %H:%M')} | {stop.strftime('%d-%m-%Y %H:%M')} | {url or '-'} |"
              )

          def main():
              tz = pytz.timezone(TZ_NAME)
              now = datetime.now(tz)
              try:
                  rows = load_rows(CSV_PATH)
              except Exception as e:
                  post_teams(f"‚ùå Failed to read schedule: {e}", "Alert")
                  return

              for raw in rows:
                  try:
                      app = require(raw, "app")
                      env = require(raw, "env")
                      if env != TARGET_ENV:
                          continue
                      start = parse_dt(require(raw, "start"), tz)
                      stop  = parse_dt(require(raw, "stop"), tz)
                      cmd   = require(raw, "cmd")
                      iid   = first_nonempty(raw, ALIASES["instanceid"]) or FALLBACK_IID
                      url   = first_nonempty(raw, ALIASES["url"])
                      if not iid:
                          raise ValueError("No InstanceId for row")

                      if not ensure_online(iid):
                          post_teams(f"‚ùå {app}: Instance {iid} not Online in SSM", "Alert")
                          continue

                      table = make_table(app, iid, start, stop, url)

                      if start <= now <= stop:
                          # inside window ‚Üí patching reminder + stopping
                          post_teams(f"üõë Patching started for **{app}** on `{iid}`", "Info", table=table)
                          rc, _, err = ssm_run(iid, cmd.replace("start", "stop"))
                          if rc != 0:
                              post_teams(f"‚ùå Failed to stop {app} on {iid}: {err}", "Alert", table=table)
                      else:
                          # outside window ‚Üí restart + done reminder
                          post_teams(f"üîÑ Restarting **{app}** on `{iid}`", "Info", table=table)
                          rc, _, err = ssm_run(iid, cmd)
                          if rc != 0:
                              post_teams(f"‚ùå Failed to restart {app} on {iid}: {err}", "Alert", table=table)
                              continue
                          time.sleep(8)
                          if url:
                              status, _ = http_status_via_ssm(iid, url)
                              if status == 200:
                                  post_teams(f"‚úÖ Patching done for **{app}** ‚Äî App is healthy", "Info", table=table)
                              else:
                                  post_teams(f"‚ùå {app} NOT healthy after patching (status {status})", "Alert", table=table)

                  except Exception as e:
                      post_teams(f"‚ùå Unexpected error for row: {e}", "Alert")

          if __name__ == "__main__":
              main()
          PY

      - name: Run patching via SSM
        run: python windowed_health_check_ssm.py
