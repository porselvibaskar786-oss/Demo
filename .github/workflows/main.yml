name: Patching Control + Teams + Auto-Restart + Dynatrace

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      DYNATRACE_URL: ${{ secrets.DYNATRACE_URL }}
      DYNATRACE_TOKEN: ${{ secrets.DYNATRACE_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install pandas requests pytz tabulate boto3

      - name: Patching + Auto-Approval + Health Check + Dynatrace Alerts
        run: |
          python <<'PY'
          import pandas as pd, os, time, requests, re, boto3, random
          from datetime import datetime, timedelta
          import pytz
          from tabulate import tabulate

          CSV_PATH = os.getenv("CSV_PATH", "schedule.csv")
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          TZ = pytz.timezone(os.getenv("TZ", "Asia/Kolkata"))
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL")
          AWS_REGION = os.getenv("AWS_REGION")
          EC2_INSTANCE_ID = os.getenv("EC2_INSTANCE_ID")
          DYNATRACE_URL = os.getenv("DYNATRACE_URL")
          DYNATRACE_TOKEN = os.getenv("DYNATRACE_TOKEN")

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          COLS = {
              "app":"app_name",
              "env":"environment",
              "start":"start_date",
              "stop":"stop_date",
              "url":"health_url",
              "cmd":"command",
              "iid":"instanceid",
              "owner":"owner",
              "approval":"approval_status"
          }

          def normalize(df):
              df.columns = [re.sub(r"[^\w]+","_",c.strip().lower()) for c in df.columns]
              for k,v in COLS.items():
                  if v not in df.columns:
                      df[v] = "-"
              if "approval_status" not in df.columns:
                  df["approval_status"] = ""
              return df

          def make_table(df):
              return tabulate(df[list(COLS.values())], headers="keys", tablefmt="github")

          def post_teams(title, message, table=None, approve_url=None, color="0076D7", file=None):
              if not TEAMS_URL: return
              sections=[{"activityTitle":title,"text":message}]
              if table: sections.append({"text":table})
              if approve_url:
                  sections.append({"potentialAction":[{"@type":"OpenUri","name":"Approve","targets":[{"os":"default","uri":approve_url}]}]})
              payload={"@type":"MessageCard","@context":"http://schema.org/extensions","themeColor":color,"summary":title,"sections":sections}
              try:
                  if file:
                      files = {'file': open(file,'rb')}
                      requests.post(TEAMS_URL, files=files, timeout=10)
                  else:
                      requests.post(TEAMS_URL,json=payload,timeout=10)
              except Exception as e: print(f"[teams] send failed: {e}")

          def save_df(df): df.to_csv(CSV_PATH,index=False)

          def parse_dt(s):
              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):
                  try: return TZ.localize(datetime.strptime(s, fmt))
                  except: pass
              raise ValueError(f"Bad date '{s}'")

          def health_check(url):
              try: return requests.get(url, timeout=5).status_code==200
              except: return False

          def restart_app_ssm(cmd, instance_id):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[cmd]},
                      TimeoutSeconds=60,
                  )
                  return resp
              except Exception as e:
                  return str(e)

          def get_dynatrace_alerts():
              alerts = []
              severities = ["CRITICAL","WARNING","INFO"]
              for _ in range(random.randint(0,2)):
                  alerts.append({
                      "title": f"Mock Alert {random.randint(1,99)}",
                      "severity": random.choice(severities),
                      "status": random.choice(["OPEN","CLOSED"])
                  })
              return alerts

          # ===== MAIN WORKFLOW =====
          df = normalize(pd.read_csv(CSV_PATH))
          now = datetime.now(TZ)

          for idx,row in df.iterrows():
              app = row[COLS["app"]]
              env = row[COLS["env"]]
              start = parse_dt(row[COLS["start"]])
              stop = parse_dt(row[COLS["stop"]])
              url = row[COLS["url"]]
              cmd = row[COLS["cmd"]]
              owner = row[COLS["owner"]]
              approval = row[COLS["approval"]].lower()

              if env != TARGET_ENV: continue
              table = make_table(df)

              # 1-week reminder
              if start - timedelta(days=7) <= now < start - timedelta(days=6, hours=23, minutes=55):
                  post_teams("â° Reminder: Patching in 1 week",
                             f"Patching for **{app}**. Owner: {owner}", table, file=CSV_PATH)
                  continue

              # 5-min reminder
              if start - timedelta(minutes=5) <= now < start - timedelta(minutes=4, seconds=55):
                  post_teams("â° Reminder: Patching starts in 5 minutes",
                             f"Patching for **{app}**. Owner: {owner}", table, file=CSV_PATH)
                  continue

              # Auto-approval
              if approval != "approved":
                  df.at[idx, COLS["approval"]] = "approved"
                  save_df(df)
                  approval = "approved"
                  post_teams(f"âœ… Auto-approved: {app}", f"Patching will start automatically.", table, file=CSV_PATH)

              # Start patching
              if approval=="approved" and start <= now <= stop:
                  post_teams(f"ðŸ›‘ Patching started: {app}", f"Patching app {app} owned by {owner}", table)
                  time.sleep(2)
                  post_teams(f"âœ… Patching done: {app}", f"{app} patching finished. Performing health check.", table)

                  healthy = health_check(url)
                  if healthy:
                      post_teams(f"ðŸ’š Health check passed: {app}", f"{app} is healthy", table)
                  else:
                      post_teams(f"âŒ Health check failed: {app}", f"{app} is unhealthy. Restarting via SSM...", table, color="FF0000")
                      if cmd and cmd!="-":
                          resp = restart_app_ssm(cmd, EC2_INSTANCE_ID)
                          post_teams(f"ðŸ”„ Restart triggered via SSM: {app}", f"Response: {resp}", table)
                          time.sleep(5)
                          if health_check(url):
                              post_teams(f"ðŸ’š Health restored: {app}", f"{app} is now healthy.", table)
                          else:
                              post_teams(f"âš  Still unhealthy: {app}", f"{app} failed to recover automatically.", table, color="FF0000")

              # Outside patching window
              if now < start or now > stop:
                  healthy = health_check(url)
                  if healthy:
                      post_teams(f"ðŸ’¡ Health check: {app}", f"{app} is healthy", table)
                  else:
                      post_teams(f"âš  Health check failed outside window: {app}", f"{app} is unhealthy.", table, color="FF0000")

          # ===== Dynatrace Alerts =====
          alerts = get_dynatrace_alerts()
          for a in alerts:
              color_map = {"CRITICAL":"FF0000","WARNING":"FFA500","INFO":"0076D7"}
              post_teams(f"âš  Dynatrace Alert: {a['title']}",
                         f"Severity: {a['severity']}\nStatus: {a['status']}",
                         color=color_map.get(a['severity'], "0076D7"))
          PY
