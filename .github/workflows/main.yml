      - name: Run patching workflow
        run: |
          python <<'PY'
          import os, time, requests, pandas as pd, boto3, pytz
          from datetime import datetime, timedelta

          CSV_PATH = os.getenv("CSV_PATH")
          TARGET_ENV = os.getenv("TARGET_ENV")
          TZ = pytz.timezone(os.getenv("TZ"))
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL")
          AWS_REGION = os.getenv("AWS_REGION")
          EC2_INSTANCE_ID = os.getenv("EC2_INSTANCE_ID")
          DYNATRACE_ENV_ID = os.getenv("DYNATRACE_ENV_ID")
          DYNATRACE_API_TOKEN = os.getenv("DYNATRACE_API_TOKEN")
          ssm = boto3.client("ssm", region_name=AWS_REGION)

          # Teams helpers
          def post_teams_table(df, title="Patching Coordination"):
              table_text = "| App | Pre-check | Patching Started | Post-patching | App Status | Health URL |\n|-----|-----------|-----------------|---------------|------------|------------|\n"
              for _, row in df.iterrows():
                  pre_check = row.get("pre_check","Pending")
                  started = row.get("patch_started","Pending")
                  post_patch = row.get("post_patch","Pending")
                  status = row.get("app_status","Pending")
                  health_url = row.get("health_url","-")
                  table_text += f"| {row['app_name']} | {pre_check} | {started} | {post_patch} | {status} | {health_url} |\n"

              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7",
                  "summary": title,
                  "sections": [{"activityTitle": f"**{title}**", "text": table_text}],
              }
              try: requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e: print(f"[teams] table failed: {e}")

          def ssm_run(instance_id, cmd, timeout_s=180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[cmd]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False},
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode",1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1,"","Timed out waiting for SSM command"
              except Exception as e:
                  return 1,"",f"SSM error: {e}"

          def http_status_via_ssm(instance_id, url):
              if not url: return None
              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              code, out, err = ssm_run(instance_id, shell)
              if code != 0: return None
              try:
                  return int(out.rsplit("HTTP_STATUS:",1)[1].strip())
              except: return None

          def ensure_online(instance_id):
              try:
                  resp = ssm.describe_instance_information(Filters=[{"Key":"InstanceIds","Values":[instance_id]}])
                  if resp["InstanceInformationList"]:
                      return resp["InstanceInformationList"][0]["PingStatus"]=="Online"
              except: pass
              return False

          def send_dynatrace_success(app):
              if not DYNATRACE_ENV_ID or not DYNATRACE_API_TOKEN: return
              try:
                  url = f"https://{DYNATRACE_ENV_ID}.apps.dynatrace.com/api/v2/events"
                  headers = {"Authorization": f"Api-Token {DYNATRACE_API_TOKEN}"}
                  payload = {"eventType":"CUSTOM_ANNOTATION","attachRules":{"entityIds":[]},
                             "source":"GitHub Actions","description":f"Patching successful for {app}"}
                  requests.post(url, headers=headers, json=payload, timeout=5)
              except Exception as e: print(f"[dynatrace] success alert failed: {e}")

          def send_dynatrace_failure(app, msg):
              if not DYNATRACE_ENV_ID or not DYNATRACE_API_TOKEN: return
              try:
                  url = f"https://{DYNATRACE_ENV_ID}.apps.dynatrace.com/api/v2/events"
                  headers = {"Authorization": f"Api-Token {DYNATRACE_API_TOKEN}"}
                  payload = {"eventType":"CUSTOM_ALERT","attachRules":{"entityIds":[]},
                             "source":"GitHub Actions","description":f"Patching FAILED for {app} - {msg}. Problem link: https://lyt09047.apps.dynatrace.com/ui/apps/dynatrace.davis.problems/"}
                  requests.post(url, headers=headers, json=payload, timeout=5)
              except Exception as e: print(f"[dynatrace] failure alert failed: {e}")

          # Load CSV
          df = pd.read_csv(CSV_PATH)
          df.columns = [c.strip().lower().replace(" ","_") for c in df.columns]
          now = datetime.now(TZ)

          # Initialize coordination columns
          for col in ["pre_check","patch_started","post_patch","app_status"]:
              if col not in df.columns: df[col] = "Pending"

          # Step 1: Pre-check
          for idx, row in df.iterrows():
              iid = row.get('instanceid') or EC2_INSTANCE_ID
              app = row['app_name']
              if ensure_online(iid):
                  df.at[idx,"pre_check"] = "Completed"
              else:
                  df.at[idx,"pre_check"] = "Failed"
                  df.at[idx,"app_status"] = "Fail"
                  send_dynatrace_failure(app,"Instance not online")
          post_teams_table(df,"Pre-check status")

          # Step 2: Patching
          for idx, row in df.iterrows():
              if row['pre_check'] != "Completed": continue
              iid = row.get('instanceid') or EC2_INSTANCE_ID
              app = row['app_name']
              df.at[idx,"patch_started"] = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")

              # Stop & Start
              ssm_run(iid,"docker stop $(docker ps -q)")
              ssm_run(iid,"docker start $(docker ps -a -q)")

              time.sleep(8)
              status = http_status_via_ssm(iid,row.get("health_url"))
              if status == 200:
                  df.at[idx,"post_patch"] = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
                  df.at[idx,"app_status"] = "Success"
                  send_dynatrace_success(app)
              else:
                  # Retry once
                  ssm_run(iid,"docker restart $(docker ps -a -q)")
                  time.sleep(8)
                  status = http_status_via_ssm(iid,row.get("health_url"))
                  df.at[idx,"post_patch"] = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
                  if status == 200:
                      df.at[idx,"app_status"] = "Success after retry"
                      send_dynatrace_success(app)
                  else:
                      df.at[idx,"app_status"] = "Fail"
                      send_dynatrace_failure(app,"Health check failed after retry")

          # Final coordination table
          post_teams_table(df,"Patching Coordination")
          df.to_csv(CSV_PATH,index=False)
          PY
