name: Windowed Health Check & Auto-Restart

on:

  workflow_dispatch:

  schedule:

    - cron: "*/5 * * * *"   # every 5 minutes

jobs:

  windowed-health:

    runs-on: ubuntu-latest

    env:

      CSV_PATH: "schedule.csv"

      TARGET_ENV: "Production"

      TZ: "Asia/Kolkata"

      # Dynatrace (add in GitHub → Settings → Secrets and variables → Actions)

      DT_URL: ${{ secrets.DT_ENV_URL }}

      DT_TOKEN: ${{ secrets.DT_TOKEN }}

      # SSH to your EC2 (add these secrets)

      SSH_USER: ${{ secrets.SSH_USER }}

      SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

      SSH_PORT: ${{ secrets.SSH_PORT }}

    steps:

      - name: Checkout repo

        uses: actions/checkout@v4

      - name: Setup Python

        uses: actions/setup-python@v5

        with:

          python-version: '3.11'

      - name: Install dependencies

        run: |

          python -m pip install --upgrade pip

          pip install pandas openpyxl requests paramiko pytz

      - name: Write SSH key

        if: env.SSH_KEY != ''

        run: |

          mkdir -p ~/.ssh

          echo "${SSH_KEY}" > ~/.ssh/id_rsa

          chmod 600 ~/.ssh/id_rsa

          printf "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

      - name: Create script

        run: |

          cat > windowed_health_check.py <<'PY'

          import os, time, csv

          from datetime import datetime

          import requests, paramiko, pytz

          import pandas as pd  # not used directly here, but installed for future use

          CSV_PATH  = os.getenv("CSV_PATH", "schedule.csv")

          TARGET_ENV = os.getenv("TARGET_ENV", "Production")

          TZ        = os.getenv("TZ", "Asia/Kolkata")

          DT_URL    = (os.getenv("DT_URL") or "").rstrip("/")

          DT_TOKEN  = os.getenv("DT_TOKEN") or ""

          SSH_USER  = os.getenv("SSH_USER") or ""

          SSH_PORT  = int(os.getenv("SSH_PORT") or "22")

          def post_dt(event_type, title, desc, status="INFO"):

              if not (DT_URL and DT_TOKEN): return

              try:

                  requests.post(

                      f"{DT_URL}/api/v2/events/ingest",

                      headers={

                          "Authorization": f"Api-Token {DT_TOKEN}",

                          "Content-type": "application/json",

                      },

                      json={

                          "eventType": event_type,

                          "title": title,

                          "description": desc,

                          "source": "GitHub Actions",

                          "status": status.lower(),

                      },

                      timeout=10,

                  )

              except Exception:

                  pass

          def parse_dt(s, tz):

              s = str(s or "").strip()

              for f in (

                  "%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M",

                  "%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M",

                  "%Y-%m-%dT%H:%M:%S",

              ):

                  try:

                      return tz.localize(datetime.strptime(s, f))

                  except Exception:

                      pass

              raise ValueError(f"Bad date: {s}")

          def ssh_run(host, cmd):

              k = paramiko.RSAKey.from_private_key_file(os.path.expanduser("~/.ssh/id_rsa"))

              c = paramiko.SSHClient()

              c.set_missing_host_key_policy(paramiko.AutoAddPolicy())

              c.connect(hostname=host, username=SSH_USER, port=SSH_PORT, pkey=k, timeout=15)

              stdin, stdout, stderr = c.exec_command(cmd)

              code = stdout.channel.recv_exit_status()

              out, err = stdout.read().decode(), stderr.read().decode()

              c.close()

              return code, out, err

          def http_status(url):

              try:

                  return requests.get(url, timeout=8).status_code

              except Exception:

                  return None

          def main():

              tz = pytz.timezone(TZ)

              now = datetime.now(tz)

              print(f"Now: {now} TZ={TZ}")

              with open(CSV_PATH, newline='', encoding='utf-8') as f:

                  reader = csv.DictReader(f)

                  for raw in reader:

                      # make lookups case-insensitive

                      row = { (k or "").strip().lower(): v for k, v in raw.items() }

                      app = row.get("app name")

                      env = (row.get("environment") or "").strip()

                      if not app or env != TARGET_ENV:

                          continue

                      start = parse_dt(row.get("start date"), tz)

                      stop  = parse_dt(row.get("stop date"), tz)

                      if not (start <= now <= stop):

                          print(f"[{app}] outside window ({start} to {stop}) – skip")

                          continue

                      host = (row.get("host") or row.get("host ") or row.get("host name") or row.get("host")).strip() if row.get("host") is not None else (raw.get("HOST") or "").strip()

                      url  = (row.get("health url") or "").strip()

                      rcmd = (row.get("command") or row.get("restart command") or "").strip()

                      code = http_status(url)

                      print(f"[{app}] health status: {code}")

                      if code == 200:

                          post_dt("CUSTOM_INFO", f"{app}: Health OK", f"{app} healthy")

                          continue

                      post_dt("CUSTOM_ALERT", f"{app}: Health Failed", f"Status {code}; restarting", status="FAILURE")

                      try:

                          rc, out, err = ssh_run(host, rcmd)

                          print(f"[{app}] restart exit={rc} out={out} err={err}")

                      except Exception as e:

                          print(f"[{app}] restart error: {e}")

                          continue

                      time.sleep(8)

                      code2 = http_status(url)

                      print(f"[{app}] health after restart: {code2}")

                      if code2 == 200:

                          post_dt("CUSTOM_INFO", f"{app}: Recovered", f"{app} recovered")

                      else:

                          post_dt("CUSTOM_ALERT", f"{app}: Still Failing", f"Status {code2}", status="FAILURE")

          if __name__ == "__main__":

              main()

          PY

      - name: Run windowed health check

        run: python windowed_health_check.py
 
