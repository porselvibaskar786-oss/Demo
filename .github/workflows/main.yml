name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata

      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

      DYNATRACE_URL: ${{ secrets.DYNATRACE_URL }}
      DYNATRACE_TOKEN: ${{ secrets.DYNATRACE_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz tabulate

      - name: Run Patching Script with Mock Approval & Dynatrace Alerts
        run: |
          cat > windowed_health_check_ssm.py <<'PY'
          import os, re, time, random
          from datetime import datetime, timedelta
          import pandas as pd
          import requests, boto3, pytz
          from tabulate import tabulate

          CSV_PATH = os.getenv("CSV_PATH", "schedule.csv")
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          TZ_NAME = os.getenv("TZ", "Asia/Kolkata")
          AWS_REGION = os.getenv("AWS_REGION")
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL") or ""
          FALLBACK_IID = (os.getenv("EC2_INSTANCE_ID") or "").strip()

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          ALIASES = {
              "app": ["app", "app_name", "application"],
              "env": ["environment", "env"],
              "start": ["start", "start_date", "window_start"],
              "stop": ["stop", "stop_date", "window_stop", "end"],
              "url": ["health_url", "health", "url"],
              "cmd": ["command", "cmd", "restart_command", "action"],
              "instanceid": ["instanceid", "instance_id", "ec2_instance_id"],
              "owner": ["owner"],
              "approval": ["approval_status"]
          }

          def first_nonempty(row, names):
              for n in names:
                  v = row.get(n, "")
                  if v is not None and str(v).strip() != "":
                      return str(v).strip()
              return ""

          def post_teams(title, message, table=None, color="0076D7"):
              if not TEAMS_URL: return
              sections = [{"activityTitle": title, "text": message}]
              if table: sections.append({"text": table})
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": color,
                  "summary": title,
                  "sections": sections,
              }
              try:
                  requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e:
                  print(f"[teams] send failed: {e}")

          def parse_dt(s, tz):
              s = (s or "").strip()
              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):
                  try: return tz.localize(datetime.strptime(s, fmt))
                  except: pass
              raise ValueError(f"Bad date '{s}'")

          def load_rows(path):
              ext = os.path.splitext(path)[1].lower()
              if ext == ".csv": df = pd.read_csv(path)
              elif ext in (".xlsx", ".xls"): df = pd.read_excel(path)
              else: raise ValueError("Input must be CSV/XLSX")
              df.columns = [re.sub(r"[^\w]+","_",c.strip().lower()) for c in df.columns]
              if "approval_status" not in df.columns: df["approval_status"] = ""
              return df

          def save_rows(df):
              df.to_csv(CSV_PATH, index=False)

          def make_table(df):
              df_disp = df[["app","instanceid","start","stop","url","owner","approval_status"]].fillna("-")
              return tabulate(df_disp, headers="keys", tablefmt="github")

          def simulate_dynatrace_alerts():
              # Random mock alerts for demo
              alerts = []
              severities = ["CRITICAL","WARNING","INFO"]
              for _ in range(random.randint(0,2)):
                  alerts.append({
                      "title": f"Mock Alert {random.randint(1,99)}",
                      "severityLevel": random.choice(severities),
                      "status": random.choice(["OPEN","CLOSED"])
                  })
              return alerts

          def main():
              tz = pytz.timezone(TZ_NAME)
              now = datetime.now(tz)
              df = load_rows(CSV_PATH)
              
              for idx, row in df.iterrows():
                  app = first_nonempty(row, ALIASES["app"])
                  env = first_nonempty(row, ALIASES["env"])
                  if env != TARGET_ENV: continue
                  start = parse_dt(first_nonempty(row, ALIASES["start"]), tz)
                  stop = parse_dt(first_nonempty(row, ALIASES["stop"]), tz)
                  iid = first_nonempty(row, ALIASES["instanceid"]) or FALLBACK_IID
                  cmd = first_nonempty(row, ALIASES["cmd"])
                  owner = first_nonempty(row, ALIASES["owner"])
                  approval = first_nonempty(row, ALIASES["approval"]).lower()
                  url = first_nonempty(row, ALIASES["url"])

                  table = make_table(df)

                  # 1-week reminder
                  if start - timedelta(days=7) <= now < start - timedelta(days=6, hours=23, minutes=55):
                      post_teams("â° Reminder: Patching in 1 week",
                                 f"Patching for **{app}**. Owner: {owner}", table)
                      continue

                  # 5-min reminder + approval simulation
                  if start - timedelta(minutes=5) <= now < start - timedelta(minutes=4, seconds=55):
                      post_teams("â° Reminder: Patching starts in 5 minutes",
                                 f"Patching for **{app}**. Owner: {owner}\nMock Approval: setting status to 'approved'",
                                 table)
                      df.at[idx,"approval_status"]="approved"
                      save_rows(df)
                      continue

                  # Post-approval patching
                  if approval == "approved" and start <= now <= stop:
                      post_teams("ðŸ›‘ Patching started", f"{app} on {iid} (Owner: {owner})", table)
                      time.sleep(2)  # simulate patching
                      post_teams("âœ… Patching done", f"{app} health status: Healthy", table)
                      continue

                  # Outside patching window: health check
                  if now < start or now > stop:
                      post_teams("ðŸ’¡ Health check", f"{app} status: Healthy", table)

              # Mock Dynatrace alerts
              alerts = simulate_dynatrace_alerts()
              for a in alerts:
                  post_teams(f"âš  Dynatrace Alert: {a['title']}",
                             f"Severity: {a['severityLevel']}\nStatus: {a['status']}",
                             color="FF0000")

          if __name__=="__main__":
              main()
          PY

          python windowed_health_check_ssm.py
