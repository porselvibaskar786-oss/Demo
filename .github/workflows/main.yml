name: Patching Control (SSM) + Teams

on:

  workflow_dispatch:

  schedule:

    - cron: "*/5 * * * *"   # every 5 minutes

jobs:

  patching-check:

    runs-on: ubuntu-latest

    env:

      # File in your repo root. Can be schedule.csv OR schedule.xlsx

      CSV_PATH: schedule.csv

      TARGET_ENV: Production

      TZ: Asia/Kolkata

      # Secrets to set in GitHub ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions

      AWS_REGION: ${{ secrets.AWS_REGION }}

      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}

      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

      # Optional fallback if a row doesn't have InstanceId

      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:

      - name: Checkout

        uses: actions/checkout@v4

      - name: Configure AWS credentials

        uses: aws-actions/configure-aws-credentials@v4

        with:

          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}

          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}

          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python

        uses: actions/setup-python@v5

        with:

          python-version: "3.11"

      - name: Install Python dependencies

        run: |

          python -m pip install --upgrade pip

          pip install boto3 requests pandas openpyxl pytz

      - name: Create SSM patching script

        run: |

          cat > windowed_health_check_ssm.py <<'PY'

          import os, re, time

          from datetime import datetime

          import pandas as pd

          import requests, boto3, pytz

          CSV_PATH     = os.getenv("CSV_PATH", "schedule.csv")

          TARGET_ENV   = os.getenv("TARGET_ENV", "Production")

          TZ_NAME      = os.getenv("TZ", "Asia/Kolkata")

          AWS_REGION   = os.getenv("AWS_REGION")

          TEAMS_URL    = os.getenv("TEAMS_WEBHOOK_URL") or ""

          FALLBACK_IID = (os.getenv("EC2_INSTANCE_ID") or "").strip()

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(message: str, level: str = "Info"):

              if not TEAMS_URL: 

                  return

              payload = {

                  "@type": "MessageCard",

                  "@context": "http://schema.org/extensions",

                  "themeColor": "0076D7" if level.lower()=="info" else "FF0000",

                  "summary": f"{level}: {message}",

                  "sections": [{ "activityTitle": f"**{level}**", "text": message }],

              }

              try:

                  requests.post(TEAMS_URL, json=payload, timeout=10)

              except Exception as e:

                  print(f"[teams] send failed: {e}")

          def norm(s: str) -> str:

              s = (s or "").strip().lower()

              s = re.sub(r"[^\w]+", "_", s)

              s = re.sub(r"_{2,}", "_", s).strip("_")

              return s

          # Flexible header aliases

          ALIASES = {

              "app":        ["app", "app_name", "appname", "application", "application_name"],

              "env":        ["environment", "env"],

              "start":      ["start", "start_date", "startdate", "window_start"],

              "stop":       ["stop", "stop_date", "stopdate", "window_stop", "end", "end_date"],

              "url":        ["health_url", "health", "url", "healthcheck", "health_check_url"],

              "cmd":        ["command", "cmd", "restart_command", "action"],

              "instanceid": ["instanceid", "instance_id", "instance", "ec2_instance_id"],

          }

          def first_nonempty(row: dict, names: list[str]) -> str:

              for n in names:

                  v = row.get(n, "")

                  if v is not None and str(v).strip() != "":

                      return str(v).strip()

              return ""

          def require(row: dict, field: str) -> str:

              v = first_nonempty(row, ALIASES[field])

              if not v:

                  raise ValueError(f"Missing required field: {field} (accepted: {ALIASES[field]})")

              return v

          def parse_dt(s: str, tz):

              s = (s or "").strip()

              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):

                  try:

                      return tz.localize(datetime.strptime(s, fmt))

                  except:

                      pass

              raise ValueError(f"Bad date '{s}'. Use 'DD-MM-YYYY HH:MM' or 'YYYY-MM-DD HH:MM'")

          def load_rows(path: str):

              ext = os.path.splitext(path)[1].lower()

              if ext == ".csv":

                  df = pd.read_csv(path)

              elif ext in (".xlsx", ".xls"):

                  df = pd.read_excel(path)

              else:

                  raise ValueError("Input must be CSV or XLS/XLSX")

              df.columns = [norm(c) for c in df.columns]

              print("Normalized headers ->", list(df.columns))

              return df.to_dict("records")

          def ssm_run(instance_id: str, command: str, timeout_s: int = 180):

              """Run a shell command on EC2 via SSM and wait for completion."""

              try:

                  resp = ssm.send_command(

                      InstanceIds=[instance_id],

                      DocumentName="AWS-RunShellScript",

                      Parameters={"commands": [command]},

                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False},

                  )

                  cmd_id = resp["Command"]["CommandId"]

                  for _ in range(timeout_s):

                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)

                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):

                          code = int(out.get("ResponseCode", 1))

                          return code, out.get("StandardOutputContent",""), out.get("StandardErrorContent","")

                      time.sleep(1)

                  return 1, "", "Timed out waiting for SSM command"

              except Exception as e:

                  return 1, "", f"SSM error: {e}"

          def http_status_via_ssm(instance_id: str, url: str):

              if not url:

                  return None, "no url"

              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'

              code, out, err = ssm_run(instance_id, shell)

              if code != 0:

                  return None, err or out

              status = None; body = out

              if "HTTP_STATUS:" in out:

                  body, tail = out.rsplit("HTTP_STATUS:", 1)

                  try:

                      status = int(tail.strip())

                  except:

                      status = None

              return status, body

          def ensure_online(instance_id: str) -> bool:

              """Quick check that instance is managed/online in SSM."""

              try:

                  resp = ssm.describe_instance_information(

                      Filters=[{"Key":"InstanceIds","Values":[instance_id]}]

                  )

                  if resp["InstanceInformationList"]:

                      return resp["InstanceInformationList"][0]["PingStatus"] == "Online"

              except Exception as e:

                  print(f"[ssm] online check failed: {e}")

              return False

          def main():

              tz = pytz.timezone(TZ_NAME)

              now = datetime.now(tz)

              print(f"Now: {now}  TZ={TZ_NAME}")

              try:

                  rows = load_rows(CSV_PATH)

              except Exception as e:

                  print(f"[fatal] read {CSV_PATH} failed: {e}")

                  post_teams(f"‚ùå Failed to read schedule: {e}", "Alert")

                  return

              any_action = False

              for raw in rows:

                  try:

                      app = require(raw, "app")

                      env = require(raw, "env")

                      if env != TARGET_ENV:

                          continue

                      start = parse_dt(require(raw, "start"), tz)

                      stop  = parse_dt(require(raw, "stop"), tz)

                      cmd   = require(raw, "cmd")

                      iid   = first_nonempty(raw, ALIASES["instanceid"]) or FALLBACK_IID

                      if not iid:

                          raise ValueError("No InstanceId in row and no EC2_INSTANCE_ID fallback")

                      url = first_nonempty(raw, ALIASES["url"])

                      any_action = True

                      if not ensure_online(iid):

                          post_teams(f"‚ùå {app}: Instance {iid} not Online in SSM", "Alert")

                          continue

                      if start <= now <= stop:

                          # inside window ‚Üí stop

                          stop_cmd = cmd.replace("start", "stop")

                          post_teams(f"üõë Patching window active for **{app}** on `{iid}` ‚Äì `{stop_cmd}`", "Info")

                          rc, out, err = ssm_run(iid, stop_cmd)

                          print(f"[{app}] stop rc={rc}\nstdout:\n{out}\nstderr:\n{err}")

                          if rc != 0:

                              post_teams(f"‚ùå Failed to stop {app} on {iid}: {err or out}", "Alert")

                      else:

                          # outside window ‚Üí (re)start + health

                          post_teams(f"‚ñ∂Ô∏è Starting **{app}** on `{iid}` ‚Äì `{cmd}`", "Info")

                          rc, out, err = ssm_run(iid, cmd)

                          print(f"[{app}] start rc={rc}\nstdout:\n{out}\nstderr:\n{err}")

                          if rc != 0:

                              post_teams(f"‚ùå Failed to start {app} on {iid}: {err or out}", "Alert")

                              continue

                          time.sleep(8)

                          if url:

                              status, _ = http_status_via_ssm(iid, url)

                              print(f"[{app}] health status = {status}")

                              if status == 200:

                                  post_teams(f"‚úÖ {app} healthy after patching", "Info")

                              else:

                                  post_teams(f"‚ùå {app} NOT healthy after patching (status {status})", "Alert")

                  except ValueError as ve:

                      print(f"[skip] row error: {ve}")

                      post_teams(f"‚ö†Ô∏è Skipping row (bad/missing fields): {ve}", "Info")

                  except Exception as e:

                      print(f"[error] unexpected: {e}")

                      post_teams(f"‚ùå Unexpected error: {e}", "Alert")

              if not any_action:

                  print("No rows matched TARGET_ENV or no valid windows.")

          if __name__ == "__main__":

              main()

          PY

      - name: Run patching via SSM

        run: python windowed_health_check_ssm.py
 
