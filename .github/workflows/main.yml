name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz

      - name: Run patching workflow with Auto-Approval
        run: |
          python <<'PY'
          import os, pandas as pd, requests, boto3, time, pytz, random
          from datetime import datetime

          CSV_PATH = os.getenv("CSV_PATH")
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL")
          TARGET_ENV = os.getenv("TARGET_ENV")
          TZ = pytz.timezone(os.getenv("TZ"))
          AWS_REGION = os.getenv("AWS_REGION")
          FALLBACK_IID = os.getenv("EC2_INSTANCE_ID")
          ssm = boto3.client("ssm", region_name=AWS_REGION)

          # Header aliases
          ALIASES = {
              "app": ["app", "app_name", "appname", "application", "application_name"],
              "env": ["environment", "env"],
              "start": ["start", "start_date", "startdate", "window_start"],
              "stop": ["stop", "stop_date", "stopdate", "window_stop", "end", "end_date"],
              "cmd": ["command", "cmd", "restart_command", "action"],
              "url": ["health_url", "health", "url", "healthcheck", "health_check_url"],
              "iid": ["instanceid", "instance_id", "instance", "ec2_instance_id"],
              "approval": ["approval_status", "approved", "approval"]
          }

          def first_nonempty(row: dict, names: list):
              for n in names:
                  v = row.get(n, "")
                  if v is not None and str(v).strip() != "":
                      return str(v).strip()
              return ""

          def require(row: dict, field: str):
              v = first_nonempty(row, ALIASES[field])
              if not v:
                  raise ValueError(f"Missing required field: {field}")
              return v

          def post_teams(msg, level="Info"):
              if not TEAMS_URL: return
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7" if level=="Info" else "FF0000",
                  "summary": f"{level}: {msg}",
                  "sections": [{"activityTitle": f"**{level}**", "text": msg}],
              }
              try: requests.post(TEAMS_URL, json=payload, timeout=10)
              except: print(f"[teams] failed to send: {msg}")

          def ssm_run(iid: str, cmd: str, timeout=180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[iid],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[cmd]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False}
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=iid)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode",1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1, "", "Timeout waiting for SSM command"
              except Exception as e:
                  return 1, "", f"SSM error: {e}"

          def http_status_via_ssm(iid: str, url: str):
              if not url: return None, "no url"
              cmd = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              code, out, err = ssm_run(iid, cmd)
              if code != 0: return None, err or out
              status = None
              if "HTTP_STATUS:" in out:
                  try: status = int(out.rsplit("HTTP_STATUS:",1)[1].strip())
                  except: status = None
              return status, out

          df = pd.read_csv(CSV_PATH)
          df.columns = [c.strip() for c in df.columns]

          # Step 1: Send schedule CSV to Teams
          post_teams("üìã Patching Schedule:\n" + df.to_string(index=False))

          now = datetime.now(TZ)
          print(f"Now={now}")

          any_action = False
          for idx,row in df.iterrows():
              try:
                  app = require(row, "app")
                  env = require(row, "env")
                  if env != TARGET_ENV: continue
                  iid = first_nonempty(row, ALIASES["iid"]) or FALLBACK_IID
                  if not iid:
                      post_teams(f"‚ùå {app}: No instance ID", "Alert")
                      continue

                  # Step 2: Auto-Approval
                  approval = first_nonempty(row, ALIASES["approval"]).lower()
                  if approval != "approved":
                      df.at[idx, first_nonempty(row, ALIASES["approval"])] = "approved"
                      post_teams(f"‚úÖ Patching scheduled & auto-approved for {app}", "Info")

                  cmd = require(row, "cmd")
                  url = first_nonempty(row, ALIASES["url"])
                  start = datetime.strptime(require(row,"start"),"%d-%m-%Y %H:%M:%S")
                  stop  = datetime.strptime(require(row,"stop"),"%d-%m-%Y %H:%M:%S")

                  # Step 3: Run patching / health check
                  if start <= now <= stop:
                      stop_cmd = cmd.replace("start","stop")
                      post_teams(f"üõë Patching active for {app} ({iid}) -> {stop_cmd}")
                      rc, out, err = ssm_run(iid, stop_cmd)
                      print(f"[{app}] stop rc={rc}\nstdout={out}\nstderr={err}")
                  else:
                      post_teams(f"‚ñ∂Ô∏è Starting {app} ({iid}) -> {cmd}")
                      rc, out, err = ssm_run(iid, cmd)
                      print(f"[{app}] start rc={rc}\nstdout={out}\nstderr={err}")
                      time.sleep(5)
                      if url:
                          status, _ = http_status_via_ssm(iid, url)
                          if status==200: post_teams(f"‚úÖ {app} healthy", "Info")
                          else: post_teams(f"‚ùå {app} unhealthy (status={status})", "Alert")
                  any_action = True
              except Exception as e:
                  post_teams(f"‚ùå Error processing row: {e}", "Alert")

          # Save any changes (approval updates)
          if any_action: df.to_csv(CSV_PATH, index=False)
          PY
