name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *" # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      SCHEDULE_FILE: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      DYNATRACE_ENV_ID: ${{ secrets.DYNATRACE_ENV_ID }}
      DYNATRACE_API_TOKEN: ${{ secrets.DYNATRACE_API_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas pytz openpyxl

      - name: Normalize schedule file headers
        run: |
          python <<'PY'
          import os, re, pandas as pd

          SCHEDULE_FILE = os.getenv("SCHEDULE_FILE", "schedule.csv")
          def normalize_header(col_name: str) -> str:
              col_name = (col_name or "").strip().lower()
              col_name = re.sub(r"[^\w]+", "_", col_name)
              col_name = re.sub(r"_{2,}", "_", col_name)
              return col_name

          ext = os.path.splitext(SCHEDULE_FILE)[1].lower()
          if ext == ".csv":
              df = pd.read_csv(SCHEDULE_FILE)
          elif ext in [".xlsx", ".xls"]:
              df = pd.read_excel(SCHEDULE_FILE)
          else:
              raise ValueError("File must be CSV or XLS/XLSX")

          df.columns = [normalize_header(c) for c in df.columns]
          df.to_csv("schedule_normalized.csv", index=False)
          print("Headers normalized:", df.columns.tolist())
          PY

      - name: Run patching + health check + Dynatrace alert
        run: |
          python <<'PY'
          import os, pandas as pd, requests, time, pytz, boto3
          from datetime import datetime

          SCHEDULE_FILE = "schedule_normalized.csv"
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          TZ = pytz.timezone(os.getenv("TZ", "Asia/Kolkata"))
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL") or ""
          AWS_REGION = os.getenv("AWS_REGION")
          EC2_FALLBACK = os.getenv("EC2_INSTANCE_ID") or ""
          DYNATRACE_ENV_ID = os.getenv("DYNATRACE_ENV_ID") or ""
          DYNATRACE_API_TOKEN = os.getenv("DYNATRACE_API_TOKEN") or ""

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(message: str, level="Info"):
              if not TEAMS_URL: return
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7" if level.lower()=="info" else "FF0000",
                  "summary": f"{level}: {message}",
                  "sections": [{"activityTitle": f"**{level}**", "text": message}]
              }
              try:
                  requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e:
                  print(f"[teams] send failed: {e}")

          def ssm_run(instance_id: str, command: str, timeout_s: int = 180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[instance_id],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands": [command]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False},
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode", 1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1, "", "Timed out"
              except Exception as e:
                  return 1, "", f"SSM error: {e}"

          def http_status_via_ssm(instance_id: str, url: str):
              if not url: return None
              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              code, out, err = ssm_run(instance_id, shell)
              if code != 0: return None
              if "HTTP_STATUS:" in out:
                  try:
                      return int(out.rsplit("HTTP_STATUS:",1)[1].strip())
                  except: return None
              return None

          df = pd.read_csv(SCHEDULE_FILE)
          now = datetime.now(TZ)

          for idx, row in df.iterrows():
              app = row.get("app_name")
              env = row.get("environment")
              if env != TARGET_ENV: continue
              start = pd.to_datetime(row.get("start_date"))
              stop  = pd.to_datetime(row.get("stop_date"))
              iid = row.get("instanceid") or EC2_FALLBACK
              cmd = row.get("command")
              url = row.get("health_url")

              if not iid or not cmd: 
                  post_teams(f"Skipping {app}: missing InstanceID/Command", "Alert")
                  continue

              if start <= now <= stop:
                  post_teams(f"🛑 Patching window active for {app} on {iid}", "Info")
                  rc, out, err = ssm_run(iid, cmd)
                  post_teams(f"✅ Patching done for {app}" if rc==0 else f"❌ Patching failed for {app}", "Info")
              else:
                  rc, out, err = ssm_run(iid, cmd)
                  post_teams(f"▶️ {app} started outside window", "Info")

              time.sleep(5)
              status = http_status_via_ssm(iid, url)
              if status == 200:
                  post_teams(f"💚 {app} healthy", "Info")
              else:
                  post_teams(f"⚠ {app} unhealthy (status {status})", "Alert")

          # Optional: send Dynatrace success alert even if patch succeeded
          if DYNATRACE_ENV_ID and DYNATRACE_API_TOKEN:
              try:
                  url = f"https://{DYNATRACE_ENV_ID}.live.dynatrace.com/api/v2/events"
                  headers = {"Authorization": f"Api-Token {DYNATRACE_API_TOKEN}", "Content-Type": "application/json"}
                  payload = {"eventType":"CUSTOM_ANNOTATION","source":"SSM Patching","annotationType":"success","attachRules":{"tagRule":[]}}
                  requests.post(url, headers=headers, json=payload, timeout=10)
                  post_teams("Dynatrace success event sent", "Info")
              except Exception as e:
                  post_teams(f"Dynatrace event failed: {e}", "Alert")
          PY
