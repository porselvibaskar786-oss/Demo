name: Windowed Health Check & Auto-Restart

on:

  workflow_dispatch:

  schedule:

    - cron: "*/5 * * * *"   # every 5 minutes

jobs:

  windowed-health:

    runs-on: ubuntu-latest

    env:

      # Excel file path (yours is at repo root)

      EXCEL_PATH: "schedule.csv"

      TARGET_ENV: "Production"

      TZ: "Asia/Kolkata"

      # Dynatrace (add in GitHub → Settings → Secrets and variables → Actions)

      DT_URL: ${{ secrets.DT_ENV_URL }}

      DT_TOKEN: ${{ secrets.DT_TOKEN }}

      # SSH to your EC2 (secrets you add)

      SSH_USER: ${{ secrets.SSH_USER }}

      SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

      SSH_PORT: ${{ secrets.SSH_PORT }}

    steps:

      - name: Checkout repo

        uses: actions/checkout@v4

      - name: Setup Python

        uses: actions/setup-python@v5

        with:

          python-version: '3.11'

      - name: Install deps

        run: |

          python -m pip install --upgrade pip

          pip install openpyxl requests paramiko pytz

      - name: Write SSH key

        if: env.SSH_KEY != ''

        run: |

          mkdir -p ~/.ssh

          echo "${SSH_KEY}" > ~/.ssh/id_rsa

          chmod 600 ~/.ssh/id_rsa

          printf "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

      - name: Create script

        run: |

          cat > windowed_health_check.py <<'PY'

          import os, time
          import pandas as pd

          from datetime import datetime

          import requests, paramiko, pytz

          EXCEL_PATH = os.getenv("EXCEL_PATH","schedule.csv")

          if  EXCEL_PATH.endswith(".csv"):
            df = pd.read_csv(EXCEL_PATH)
          else:
            import openpyxl
            df = pd.read_excel(EXCEL_PATH)
          print(df.head())  
          
          TARGET_ENV = os.getenv("TARGET_ENV","Production")

          TZ = os.getenv("TZ","Asia/Kolkata")

          DT_URL = (os.getenv("DT_URL") or "").rstrip("/")

          DT_TOKEN = os.getenv("DT_TOKEN") or ""

          SSH_USER = os.getenv("SSH_USER") or ""

          SSH_PORT = int(os.getenv("SSH_PORT") or "22")

          def post_dt(event_type, title, desc, status="INFO"):

            if not (DT_URL and DT_TOKEN): return

            try:

              requests.post(

                f"{DT_URL}/api/v2/events/ingest",

                headers={"Authorization": f"Api-Token {DT_TOKEN}",

                         "Content-type": "application/json"},

                json={"eventType": event_type, "title": title,

                      "description": desc, "source":"GitHub Actions",

                      "status": status.lower()},

                timeout=10)

            except: pass

          def parse_dt(s, tz):

            s = str(s).strip()

            for f in ["%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M",

                      "%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M",

                      "%Y-%m-%dT%H:%M:%S"]:

              try:

                return tz.localize(datetime.strptime(s,f))

              except: pass

            raise ValueError(f"Bad date: {s}")

          def ssh_run(host, cmd):

            k = paramiko.RSAKey.from_private_key_file(os.path.expanduser("~/.ssh/id_rsa"))

            c = paramiko.SSHClient(); c.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            c.connect(hostname=host, username=SSH_USER, port=SSH_PORT, pkey=k, timeout=15)

            stdin, stdout, stderr = c.exec_command(cmd)

            code = stdout.channel.recv_exit_status()

            out, err = stdout.read().decode(), stderr.read().decode()

            c.close()

            return code, out, err

          def http_status(url):

            try:

              return requests.get(url, timeout=8).status_code

            except: return None

          def main():

            tz = pytz.timezone(TZ)

            now = datetime.now(tz)

         with open(EXCEL_PATH, newline='') as f:
   reader = csv.DictReader(f)
   for row in reader:
       app = row["App Name"]
       start = row["Start Date"]
       stop = row["Stop Date"]
       env = row["Environment"]
       host = row["Host"]
       url = row["Health URL"]
       rcmd = row["Restart Command"]
       # then continue same as before

            name_to_idx = {h: i for i,h in enumerate(headers)}

            req_cols = ["App Name","Start Date","Stop Date","Environment","Host","Health URL","Restart Command"]

            for r in req_cols:

              if r not in name_to_idx: raise RuntimeError(f"Missing column: {r}")

            print(f"Now: {now}  TZ={TZ}")

            for row in ws.iter_rows(min_row=2):

              app   = row[name_to_idx["App Name"]].value

              env   = str(row[name_to_idx["Environment"]].value or "").strip()

              if not app or env != TARGET_ENV: continue

              start = parse_dt(row[name_to_idx["Start Date"]].value, tz)

              stop  = parse_dt(row[name_to_idx["Stop Date"]].value, tz)

              if not (start <= now <= stop):

                print(f"[{app}] outside window ({start} to {stop}) – skip")

                continue

              host  = str(row[name_to_idx["Host"]].value).strip()

              url   = str(row[name_to_idx["Health URL"]].value).strip()

              rcmd  = str(row[name_to_idx["Restart Command"]].value).strip()

              code = http_status(url)

              print(f"[{app}] health status: {code}")

              if code == 200:

                post_dt("CUSTOM_INFO", f"{app}: Health OK", f"{app} healthy")

                continue

              post_dt("CUSTOM_ALERT", f"{app}: Health Failed", f"Status {code}; restarting", status="FAILURE")

              try:

                rc, out, err = ssh_run(host, rcmd)

                print(f"[{app}] restart exit={rc} out={out} err={err}")

              except Exception as e:

                print(f"[{app}] restart error: {e}")

                continue

              time.sleep(8)

              code2 = http_status(url)

              print(f"[{app}] health after restart: {code2}")

              if code2 == 200:

                post_dt("CUSTOM_INFO", f"{app}: Recovered", f"{app} recovered")

              else:

                post_dt("CUSTOM_ALERT", f"{app}: Still Failing", f"Status {code2}", status="FAILURE")

          if __name__ == "__main__":

            main()

          PY

      - name: Run windowed health check

        run: python windowed_health_check.py
 
