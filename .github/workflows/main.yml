name: Patching Control (SSM) + Teams (no SSH keys)

on:

  workflow_dispatch:

  schedule:

    - cron: "*/5 * * * *"   # every 5 minutes

jobs:

  patching-check:

    runs-on: ubuntu-latest

    env:

      CSV_PATH: "schedule.csv"        # or schedule.xlsx

      TARGET_ENV: "Production"

      TZ: "Asia/Kolkata"

      AWS_REGION: ${{ secrets.AWS_REGION }}

      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

    steps:

      - name: Checkout

        uses: actions/checkout@v4

      # ---- AuthN to AWS (OIDC recommended) ----

      - name: Configure AWS credentials (OIDC)

        uses: aws-actions/configure-aws-credentials@v4

        with:

          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

          aws-region: ${{ secrets.AWS_REGION }}

      # (If you prefer access keys instead of OIDC, replace the step above with:)

      # - name: Configure AWS credentials (keys)

      #   uses: aws-actions/configure-aws-credentials@v4

      #   with:

      #     aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}

      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      #     aws-region:            ${{ secrets.AWS_REGION }}

      - name: Verify SSM online

        env:

          IID: ${{ secrets.EC2_INSTANCE_ID }}

        run: |

          set -e

          echo "Checking SSM registration for $IID in $AWS_REGION"

          aws ssm describe-instance-information --region "$AWS_REGION" \

            --query "InstanceInformationList[?InstanceId=='$IID'].[InstanceId,PingStatus]" \

            --output table

          # Optional hard fail if not Online:

          status=$(aws ssm describe-instance-information --region "$AWS_REGION" \

            --query "InstanceInformationList[?InstanceId=='$IID'].PingStatus|[0]" --output text)

          if [ "$status" != "Online" ]; then

            echo "Instance is not Online in SSM. Ensure SSM Agent is installed/running and role attached."

            exit 1

          fi

      - name: Setup Python

        uses: actions/setup-python@v5

        with:

          python-version: "3.11"

      - name: Install deps

        run: |

          python -m pip install --upgrade pip

          pip install boto3 requests pandas openpyxl pytz

      - name: Create SSM patching script

        run: |

          cat > windowed_health_check_ssm.py <<'PY'

          import os, time

          from datetime import datetime

          import requests, boto3, pytz

          import pandas as pd

          CSV_PATH   = os.getenv("CSV_PATH", "schedule.csv")

          TARGET_ENV = os.getenv("TARGET_ENV", "Production")

          TZ_NAME    = os.getenv("TZ", "Asia/Kolkata")

          TEAMS_URL  = os.getenv("TEAMS_WEBHOOK_URL") or ""

          AWS_REGION = os.getenv("AWS_REGION")

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(message, level="Info"):

              if not TEAMS_URL: return

              payload = {

                  "@type": "MessageCard",

                  "@context": "http://schema.org/extensions",

                  "themeColor": "0076D7" if level.lower()=="info" else "FF0000",

                  "summary": f"{level}: {message}",

                  "sections": [{"activityTitle": f"**{level}**", "text": message}]

              }

              try:

                  requests.post(TEAMS_URL, json=payload, timeout=10)

              except Exception as e:

                  print("Teams send failed:", e)

          def parse_dt(s, tz):

              s = str(s or "").strip()

              for f in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):

                  try:

                      return tz.localize(datetime.strptime(s, f))

                  except Exception:

                      pass

              raise ValueError(f"Bad date: {s}")

          def load_rows(path):

              ext = os.path.splitext(path)[1].lower()

              if ext == ".csv":

                  df = pd.read_csv(path)

              elif ext in (".xlsx", ".xls"):

                  df = pd.read_excel(path)

              else:

                  raise ValueError("Use CSV or XLSX")

              df.columns = [c.strip().lower() for c in df.columns]

              return df.to_dict("records")

          def ssm_run(instance_id, command, timeout_s=120):

              resp = ssm.send_command(

                  InstanceIds=[instance_id],

                  DocumentName="AWS-RunShellScript",

                  Parameters={"commands": [command]},

                  CloudWatchOutputConfig={"CloudWatchOutputEnabled": False},

              )

              cmd_id = resp["Command"]["CommandId"]

              # poll for completion

              for _ in range(timeout_s):

                  out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)

                  if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):

                      code = int(out.get("ResponseCode", 1))

                      return code, out.get("StandardOutputContent",""), out.get("StandardErrorContent","")

                  time.sleep(1)

              return 1, "", "Timed out waiting for SSM command"

          def http_status_via_ssm(instance_id, url):

              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'

              code, out, err = ssm_run(instance_id, shell, timeout_s=180)

              if code != 0:

                  return None, f"curl failed: {err or out}"

              status = None

              body = out

              if "HTTP_STATUS:" in out:

                  parts = out.rsplit("HTTP_STATUS:", 1)

                  body = parts[0].strip()

                  try: status = int(parts[1].strip())

                  except: status = None

              return status, body

          def main():

              tz = pytz.timezone(TZ_NAME)

              now = datetime.now(tz)

              print(f"Now: {now}  TZ={TZ_NAME}")

              fallback_iid = os.getenv("EC2_INSTANCE_ID", "").strip()

              for raw in load_rows(CSV_PATH):

                  # normalize keys

                  app   = (raw.get("app name") or raw.get("appname") or "").strip()

                  env   = (raw.get("environment") or "").strip()

                  if not app or env != TARGET_ENV:

                      continue

                  try:

                      start = parse_dt(raw.get("start date"), tz)

                      stop  = parse_dt(raw.get("stop date"), tz)

                  except Exception as e:

                      print(f"[{app}] bad date: {e} — skipping")

                      continue

                  url   = (raw.get("health url") or "").strip()

                  cmd   = (raw.get("command") or "").strip()

                  iid   = (raw.get("instanceid") or fallback_iid or "").strip()

                  if not iid:

                      print(f"[{app}] no InstanceId, skipping")

                      continue

                  if not cmd:

                      print(f"[{app}] no Command, skipping")

                      continue

                  if start <= now <= stop:

                      # Inside window: STOP (replace 'start' with 'stop' in command)

                      stop_cmd = cmd.replace("start", "stop")

                      post_teams(f"🛑 Patching started for **{app}** on {iid} – running `{stop_cmd}`", "Info")

                      rc, out, err = ssm_run(iid, stop_cmd)

                      print(f"[{app}] stop rc={rc} out={out} err={err}")

                      if rc != 0:

                          post_teams(f"❌ Failed to stop {app}: {err or out}", "Alert")

                  else:

                      # Outside window: START then health check

                      post_teams(f"▶️ Starting **{app}** on {iid} – `{cmd}`", "Info")

                      rc, out, err = ssm_run(iid, cmd)

                      print(f"[{app}] start rc={rc} out={out} err={err}")

                      if rc != 0:

                          post_teams(f"❌ Failed to start {app}: {err or out}", "Alert")

                          continue

                      time.sleep(8)

                      if url:

                          status, body = http_status_via_ssm(iid, url)

                          print(f"[{app}] health {status}")

                          if status == 200:

                              post_teams(f"✅ {app} healthy after patching", "Info")

                          else:

                              post_teams(f"❌ {app} NOT healthy after patching (status {status})", "Alert")

          if __name__ == "__main__":

              main()

          PY

      - name: Run windowed patching via SSM

        env:

          EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

        run: python windowed_health_check_ssm.py
 
