name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"  # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz

      - name: Full Patching Workflow
        run: |
          python <<'PY'
          import os, pandas as pd, requests, boto3, time, pytz
          from datetime import datetime, timedelta

          # Environment
          CSV_PATH = os.getenv("CSV_PATH")
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL")
          TARGET_ENV = os.getenv("TARGET_ENV")
          TZ = pytz.timezone(os.getenv("TZ"))
          AWS_REGION = os.getenv("AWS_REGION")
          FALLBACK_IID = os.getenv("EC2_INSTANCE_ID")
          ssm = boto3.client("ssm", region_name=AWS_REGION)

          # Teams helper
          def post(msg, level="Info"):
              if not TEAMS_URL: return
              try:
                  payload = {
                      "@type":"MessageCard",
                      "@context":"http://schema.org/extensions",
                      "themeColor":"0076D7" if level=="Info" else "FF0000",
                      "summary": f"{level}: {msg}",
                      "sections":[{"activityTitle": f"**{level}**", "text": msg}],
                  }
                  requests.post(TEAMS_URL,json=payload,timeout=10)
              except Exception as e:
                  print(f"[teams] send failed: {e}")

          # Load CSV
          df = pd.read_csv(CSV_PATH)
          now = datetime.now(TZ)

          # Step 1: Send CSV schedule
          post("ðŸ“‹ Patching Schedule:\n" + df.to_string(index=False))

          # Step 2: Auto-approve
          changed=False
          for idx,row in df.iterrows():
              if str(row.get("approval_status","")).lower() != "approved":
                  df.at[idx,"approval_status"]="approved"
                  post(f"âœ… Patching scheduled & auto-approved: {row['App Name']}")
                  changed=True
          if changed: df.to_csv(CSV_PATH,index=False)

          # Helpers
          def ssm_run(iid, cmd, timeout_s=180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[iid],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[cmd]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled":False},
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=iid)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode",1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1,"","Timed out"
              except Exception as e:
                  return 1,"",f"SSM error: {e}"

          def http_status(iid,url):
              if not url: return None
              shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              code, out, err = ssm_run(iid, shell)
              if code != 0: return None
              if "HTTP_STATUS:" in out:
                  _, tail = out.rsplit("HTTP_STATUS:",1)
                  try: return int(tail.strip())
                  except: return None
              return None

          # Step 3: Patch + health
          for idx,row in df.iterrows():
              app = row.get("App Name")
              env = row.get("Environment")
              if env != TARGET_ENV: continue
              iid = row.get("InstanceID") or FALLBACK_IID
              cmd = row.get("Command")
              url = row.get("health URL")
              start = TZ.localize(datetime.strptime(row["start Date"],"%d-%m-%Y %H:%M:%S"))
              stop  = TZ.localize(datetime.strptime(row["stop Date"],"%d-%m-%Y %H:%M:%S"))
              approval = str(row.get("approval_status","")).lower()
              if not iid or not cmd: continue

              # Inside window
              if start <= now <= stop and approval=="approved":
                  post(f"ðŸ›‘ Patching started for {app}")
                  stop_cmd = cmd.replace("start","stop")
                  rc, out, err = ssm_run(iid, stop_cmd)
                  post(f"[{app}] stop rc={rc}, stdout={out}, stderr={err}")
                  rc, out, err = ssm_run(iid, cmd)
                  time.sleep(5)
                  status = http_status(iid,url)
                  if status==200: post(f"âœ… {app} healthy after patching")
                  else: post(f"âš  {app} unhealthy after patching (status {status})")
              else:
                  # Outside window, ensure healthy
                  rc, out, err = ssm_run(iid, cmd)
                  time.sleep(5)
                  status = http_status(iid,url)
                  if status==200: post(f"ðŸ’š {app} healthy (outside window)")
                  else: post(f"âš  {app} unhealthy (outside window) â€” attempted restart")

          PY
