name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata

      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

      DYNATRACE_URL: ${{ secrets.DYNATRACE_URL }}
      DYNATRACE_TOKEN: ${{ secrets.DYNATRACE_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz

      - name: Create & Run Patching Script
        run: |
          cat > windowed_health_check_ssm.py <<'PY'
          import os, re, time
          from datetime import datetime, timedelta
          import pandas as pd
          import requests, boto3, pytz

          CSV_PATH     = os.getenv("CSV_PATH", "schedule.csv")
          TARGET_ENV   = os.getenv("TARGET_ENV", "Production")
          TZ_NAME      = os.getenv("TZ", "Asia/Kolkata")
          AWS_REGION   = os.getenv("AWS_REGION")
          TEAMS_URL    = os.getenv("TEAMS_WEBHOOK_URL") or ""
          FALLBACK_IID = (os.getenv("EC2_INSTANCE_ID") or "").strip()
          DYNATRACE_URL   = os.getenv("DYNATRACE_URL", "")
          DYNATRACE_TOKEN = os.getenv("DYNATRACE_TOKEN", "")

          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(title, message, table=None, color="0076D7"):
              if not TEAMS_URL: return
              sections = [{"activityTitle": title, "text": message}]
              if table: sections.append({"text": table})
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": color,
                  "summary": title,
                  "sections": sections,
              }
              try: requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e: print(f"[teams] send failed: {e}")

          def norm(s): return re.sub(r"_{2,}", "_", re.sub(r"[^\w]+","_", (s or "").strip().lower())).strip("_")

          ALIASES = {
              "app": ["app", "app_name", "application"],
              "env": ["environment", "env"],
              "start": ["start","start_date","window_start"],
              "stop": ["stop","stop_date","window_stop","end"],
              "url": ["health_url","health","url"],
              "cmd": ["command","cmd","restart_command","action"],
              "instanceid": ["instanceid","instance_id","ec2_instance_id"],
          }

          def first_nonempty(row,names):
              for n in names:
                  v = row.get(n,"")
                  if v and str(v).strip()!="": return str(v).strip()
              return ""

          def require(row,field):
              v=first_nonempty(row,ALIASES[field])
              if not v: raise ValueError(f"Missing required field: {field}")
              return v

          def parse_dt(s,tz):
              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M"):
                  try: return tz.localize(datetime.strptime((s or "").strip(),fmt))
                  except: pass
              raise ValueError(f"Bad date '{s}'")

          def load_rows(path):
              ext=os.path.splitext(path)[1].lower()
              df=pd.read_csv(path) if ext==".csv" else pd.read_excel(path)
              df.columns=[norm(c) for c in df.columns]
              return df.to_dict("records")

          def ssm_run(iid, cmd, timeout_s=180):
              try:
                  resp=ssm.send_command(InstanceIds=[iid],DocumentName="AWS-RunShellScript",Parameters={"commands":[cmd]})
                  cid=resp["Command"]["CommandId"]
                  for _ in range(timeout_s):
                      out=ssm.get_command_invocation(CommandId=cid,InstanceId=iid)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode",1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1,"","Timed out"
              except Exception as e: return 1,"",f"SSM error: {e}"

          def http_status(iid,url):
              if not url: return None,"no url"
              cmd=f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'
              rc,out,err=ssm_run(iid,cmd)
              if rc!=0: return None,err or out
              status=None
              if "HTTP_STATUS:" in out:
                  _,tail=out.rsplit("HTTP_STATUS:",1)
                  try: status=int(tail.strip())
                  except: pass
              return status,out

          def ensure_online(iid):
              try:
                  resp=ssm.describe_instance_information(Filters=[{"Key":"InstanceIds","Values":[iid]}])
                  if resp["InstanceInformationList"]:
                      return resp["InstanceInformationList"][0]["PingStatus"]=="Online"
              except: print(f"[ssm] check failed")
              return False

          def dynatrace_problems():
              if not (DYNATRACE_URL and DYNATRACE_TOKEN): return []
              try:
                  r=requests.get(f"{DYNATRACE_URL}/api/v2/problems", headers={"Authorization":f"Api-Token {DYNATRACE_TOKEN}"},timeout=10)
                  if r.status_code==200: return r.json().get("problems",[])
              except: print("[dynatrace] error")
              return []

          def make_table(app,iid,start,stop,url):
              return f"| App | Instance | Start | End | Health URL |\n|-----|----------|-------|-----|------------|\n| {app} | {iid} | {start.strftime('%d-%m-%Y %H:%M')} | {stop.strftime('%d-%m-%Y %H:%M')} | {url or '-'} |"

          def main():
              tz=pytz.timezone(TZ_NAME)
              now=datetime.now(tz)
              try: rows=load_rows(CSV_PATH)
              except Exception as e:
                  post_teams("‚ùå Schedule load failed",str(e),color="FF0000")
                  return

              for raw in rows:
                  try:
                      app=require(raw,"app")
                      env=require(raw,"env")
                      if env!=TARGET_ENV: continue
                      start=parse_dt(require(raw,"start"),tz)
                      stop=parse_dt(require(raw,"stop"),tz)
                      cmd=require(raw,"cmd")
                      iid=first_nonempty(raw,ALIASES["instanceid"]) or FALLBACK_IID
                      url=first_nonempty(raw,ALIASES["url"])
                      if not iid: raise ValueError("No InstanceId")
                      if not ensure_online(iid):
                          post_teams(f"‚ùå {app}: Instance {iid} not Online",color="FF0000")
                          continue

                      table=make_table(app,iid,start,stop,url)

                      # 1 week reminder
                      if start-timedelta(days=7)<=now<start-timedelta(days=6, hours=23, minutes=55):
                          post_teams("‚è∞ Reminder",f"Patching for **{app}** in 1 week",table)
                          continue

                      # 5 minutes prior
                      if start-timedelta(minutes=5)<=now<start-timedelta(minutes=4, seconds=55):
                          post_teams("‚è∞ Reminder",f"Patching for **{app}** starts in 5 minutes",table)
                          continue

                      # After patching
                      if now > stop:
                          post_teams("üîÑ Post-patching restart",f"Restarting **{app}** on {iid} to ensure health",table)
                          rc,_,err=ssm_run(iid,cmd)
                          status,_=http_status(iid,url)
                          msg="‚úÖ App is healthy after patching" if status==200 else "‚ùå App is NOT healthy after patching!"
                          color="00FF00" if status==200 else "FF0000"
                          post_teams("‚úÖ Post-patching health",msg,table,color=color)

                      # Outside patching: normal health check
                      elif now < start or now > stop:
                          status,_=http_status(iid,url)
                          msg="‚úÖ App is healthy" if status==200 else "‚ùå App is NOT healthy!"
                          color="00FF00" if status==200 else "FF0000"
                          post_teams("üí° Health check",msg,table,color=color)

                      # Dynatrace alerts
                      for p in dynatrace_problems():
                          title=p.get("title","Dynatrace Problem")
                          sev=p.get("severityLevel","UNKNOWN")
                          stat=p.get("status","UNKNOWN")
                          post_teams(f"‚ö† Dynatrace Alert: {title}",f"Status: {stat}\nSeverity: {sev}",color="FF0000")

                  except Exception as e:
                      post_teams(f"‚ùå Unexpected error for {app}",str(e),color="FF0000")

          if __name__=="__main__":
              main()
          PY

          python windowed_health_check_ssm.py
