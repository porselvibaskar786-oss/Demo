name: Windowed Health Check & Auto-Restart 

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes

jobs:
  windowed-health:
    runs-on: ubuntu-latest

    env:
      FILE_PATH: "schedule.csv"
      TARGET_ENV: "Production"
      TZ: "Asia/Kolkata"

      # Secrets
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      DT_URL: ${{ secrets.DT_ENV_URL }}
      DT_TOKEN: ${{ secrets.DT_TOKEN }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests paramiko pytz

      - name: Write SSH key
        if: env.SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

      - name: Create script with Teams + Dynatrace integration
        run: |
          cat > windowed_health_check.py <<'PY'
          import os, time, csv
          from datetime import datetime
          import requests, paramiko, pytz

          FILE_PATH = os.getenv("FILE_PATH", "schedule.csv")
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          TZ = os.getenv("TZ", "Asia/Kolkata")
          SSH_USER = os.getenv("SSH_USER") or ""
          SSH_PORT = int(os.getenv("SSH_PORT") or "22")
          TEAMS_WEBHOOK_URL = os.getenv("TEAMS_WEBHOOK_URL") or ""
          DT_URL = (os.getenv("DT_URL") or "").rstrip("/")
          DT_TOKEN = os.getenv("DT_TOKEN") or ""

          def post_teams(message):
              if not TEAMS_WEBHOOK_URL: return
              try:
                  requests.post(TEAMS_WEBHOOK_URL, json={"text": message}, timeout=10)
              except Exception as e:
                  print(f"Teams notification failed: {e}")

          def post_dt(event_type, title, desc, status="INFO"):
              if not (DT_URL and DT_TOKEN): return
              try:
                  requests.post(
                      f"{DT_URL}/api/v2/events/ingest",
                      headers={"Authorization": f"Api-Token {DT_TOKEN}", "Content-type": "application/json"},
                      json={"eventType": event_type, "title": title, "description": desc, "source": "GitHub Actions", "status": status.lower()},
                      timeout=10)
              except Exception as e:
                  print(f"Dynatrace alert failed: {e}")

          def parse_dt(s, tz):
              s = str(s or "").strip()
              for f in ("%d-%m-%Y %H:%M:%S", "%d-%m-%Y %H:%M", "%Y-%m-%d %H:%M:%S", "%Y-%m-%d %H:%M", "%Y-%m-%dT%H:%M:%S"):
                  try: return tz.localize(datetime.strptime(s, f))
                  except Exception: pass
              raise ValueError(f"Bad date: {s}")

          def ssh_run(host, cmd):
              k = paramiko.RSAKey.from_private_key_file(os.path.expanduser("~/.ssh/id_rsa"))
              c = paramiko.SSHClient(); c.set_missing_host_key_policy(paramiko.AutoAddPolicy())
              c.connect(hostname=host, username=SSH_USER, port=SSH_PORT, pkey=k, timeout=15)
              stdin, stdout, stderr = c.exec_command(cmd)
              code = stdout.channel.recv_exit_status()
              out, err = stdout.read().decode(), stderr.read().decode()
              c.close()
              return code, out, err

          def http_status(url):
              try: return requests.get(url, timeout=8).status_code
              except Exception: return None

          def main():
              tz = pytz.timezone(TZ)
              now = datetime.now(tz)
              print(f"Now: {now}  TZ={TZ}")
              with open(FILE_PATH, newline='', encoding='utf-8') as f:
                  reader = csv.DictReader(f)
                  for row in reader:
                      app   = row.get("App Name", "").strip()
                      env   = row.get("Environment", "").strip()
                      if not app or env != TARGET_ENV: continue
                      start = parse_dt(row.get("Start Date"), tz)
                      stop  = parse_dt(row.get("Stop Date"), tz)
                      if not (start <= now <= stop):
                          print(f"[{app}] outside window ({start} to {stop}) – skip")
                          post_teams(f"⏹️ Patching window ended for {app} ({stop})")
                          continue
                      host  = row.get("HOST", "").strip()
                      url   = row.get("health URL", "").strip()
                      rcmd  = row.get("Command", "").strip()
                      post_teams(f"🔧 Patching started for {app} ({start} to {stop})")
                      post_dt("CUSTOM_INFO", f"{app}: Patching Started", f"{app} patching window started")
                      code = http_status(f"http://{url}")
                      print(f"[{app}] health status: {code}")
                      if code == 200:
                          post_teams(f"✅ {app} is healthy")
                          post_dt("CUSTOM_INFO", f"{app}: Health OK", f"{app} healthy")
                          continue
                      post_teams(f"🚨 {app} health failed. Restarting...")
                      post_dt("CUSTOM_ALERT", f"{app}: Health Failed", f"Status {code}; restarting", status="FAILURE")
                      try:
                          rc, out, err = ssh_run(host, rcmd)
                          print(f"[{app}] restart exit={rc} out={out} err={err}")
                          post_teams(f"🔁 {app} restart command executed. Exit={rc}")
                      except Exception as e:
                          print(f"[{app}] restart error: {e}")
                          post_teams(f"❌ {app} restart failed: {e}")
                          continue
                      time.sleep(8)
                      code2 = http_status(f"http://{url}")
                      print(f"[{app}] health after restart: {code2}")
                      if code2 == 200:
                          post_teams(f"✅ {app} recovered after restart")
                          post_dt("CUSTOM_INFO", f"{app}: Recovered", f"{app} recovered")
                      else:
                          post_teams(f"🚨 {app} still failing after restart")
                          post_dt("CUSTOM_ALERT", f"{app}: Still Failing", f"Status {code2}", status="FAILURE")

          if __name__ == "__main__":
              main()
          PY

      - name: Run windowed health check
        run: python windowed_health_check.py
