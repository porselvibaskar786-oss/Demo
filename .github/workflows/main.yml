name: Windowed Health Check & Auto-Restart

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes

jobs:
  windowed-health:
    runs-on: ubuntu-latest
    env:
      CSV_PATH: "schedule.csv"
      TARGET_ENV: "Production"
      TZ: "Asia/Kolkata"

      # Dynatrace (optional – add in GitHub → Settings → Secrets and variables → Actions)
      DT_URL: ${{ secrets.DT_ENV_URL }}
      DT_TOKEN: ${{ secrets.DT_TOKEN }}

      # Microsoft Teams webhook
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}

      # SSH EC2 (add these secrets)
      SSH_USER: ${{ secrets.SSH_USER }}
      SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      SSH_PORT: ${{ secrets.SSH_PORT }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests paramiko pytz

      - name: Write SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          printf "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

      - name: Create script
        run: |
          cat > windowed_health_check.py <<'PY'
          import os, time, csv
          from datetime import datetime
          import requests, paramiko, pytz

          CSV_PATH   = os.getenv("CSV_PATH", "schedule.csv")
          TARGET_ENV = os.getenv("TARGET_ENV", "Production")
          TZ         = os.getenv("TZ", "Asia/Kolkata")

          DT_URL   = (os.getenv("DT_URL") or "").rstrip("/")
          DT_TOKEN = os.getenv("DT_TOKEN") or ""
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL") or ""

          SSH_USER = os.getenv("SSH_USER") or ""
          SSH_PORT = int(os.getenv("SSH_PORT") or "22")

          def post_teams(message, level="Info"):
              if not TEAMS_URL:
                  return
              try:
                  payload = {
                      "@type": "MessageCard",
                      "@context": "http://schema.org/extensions",
                      "themeColor": "0076D7" if level.lower()=="info" else "FF0000",
                      "summary": f"{level}: {message}",
                      "sections": [{
                          "activityTitle": f"**{level}**",
                          "text": message
                      }]
                  }
                  requests.post(TEAMS_URL, json=payload, timeout=10)
              except Exception as e:
                  print(f"Teams send failed: {e}")

          def parse_dt(s, tz):
              s = str(s or "").strip()
              for f in (
                  "%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M",
                  "%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M",
                  "%Y-%m-%dT%H:%M:%S",
              ):
                  try:
                      return tz.localize(datetime.strptime(s, f))
                  except Exception:
                      pass
              raise ValueError(f"Bad date: {s}")

          def ssh_run(host, cmd):
              k = paramiko.RSAKey.from_private_key_file(os.path.expanduser("~/.ssh/id_rsa"))
              c = paramiko.SSHClient()
              c.set_missing_host_key_policy(paramiko.AutoAddPolicy())
              c.connect(hostname=host, username=SSH_USER, port=SSH_PORT, pkey=k, timeout=15)
              stdin, stdout, stderr = c.exec_command(cmd)
              code = stdout.channel.recv_exit_status()
              out, err = stdout.read().decode(), stderr.read().decode()
              c.close()
              return code, out, err

          def http_status(url):
              try:
                  return requests.get(url, timeout=8).status_code
              except Exception:
                  return None

          def main():
              tz = pytz.timezone(TZ)
              now = datetime.now(tz)
              print(f"Now: {now} TZ={TZ}")

              with open(CSV_PATH, newline='', encoding='utf-8') as f:
                  reader = csv.DictReader(f)
                  for raw in reader:
                      row = { (k or "").strip().lower(): v for k, v in raw.items() }
                      app = row.get("app name")
                      env = (row.get("environment") or "").strip()
                      if not app or env != TARGET_ENV:
                          continue

                      start = parse_dt(row.get("start date"), tz)
                      stop  = parse_dt(row.get("stop date"), tz)
                      host = (row.get("host") or "").strip()
                      url  = (row.get("health url") or "").strip()
                      stop_cmd = (row.get("stop command") or f"docker stop {app.lower()}").strip()
