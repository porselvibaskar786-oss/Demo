import os, time, csv

from datetime import datetime

import requests, boto3, pytz

import pandas as pd

CSV_PATH   = os.getenv("CSV_PATH", "schedule.csv")

TARGET_ENV = os.getenv("TARGET_ENV", "Production")

TZ_NAME    = os.getenv("TZ", "Asia/Kolkata")

TEAMS_URL  = os.getenv("TEAMS_WEBHOOK_URL") or ""

AWS_REGION = os.getenv("AWS_REGION")

ssm = boto3.client("ssm", region_name=AWS_REGION)

def post_teams(message, level="Info"):

    if not TEAMS_URL: return

    payload = {

        "@type": "MessageCard",

        "@context": "http://schema.org/extensions",

        "themeColor": "0076D7" if level.lower()=="info" else "FF0000",

        "summary": f"{level}: {message}",

        "sections": [{"activityTitle": f"**{level}**", "text": message}]

    }

    try:

        requests.post(TEAMS_URL, json=payload, timeout=10)

    except Exception as e:

        print("Teams send failed:", e)

def parse_dt(s, tz):

    s = str(s or "").strip()

    fmts = ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S","%Y-%m-%d %H:%M")

    for f in fmts:

        try: return tz.localize(datetime.strptime(s, f))

        except: pass

    raise ValueError(f"Bad date: {s}")

def load_rows(path):

    ext = os.path.splitext(path)[1].lower()

    if ext == ".csv":

        df = pd.read_csv(path)

    elif ext in (".xlsx", ".xls"):

        df = pd.read_excel(path)

    else:

        raise ValueError("Use CSV or XLSX")

    df.columns = [c.strip().lower() for c in df.columns]

    return df.to_dict("records")

def ssm_run(instance_id, command, timeout_s=60):

    # Run shell command through SSM and return (status_code, stdout, stderr)

    resp = ssm.send_command(

        InstanceIds=[instance_id],

        DocumentName="AWS-RunShellScript",

        Parameters={"commands": [command]},

        CloudWatchOutputConfig={"CloudWatchOutputEnabled": False},

    )

    cmd_id = resp["Command"]["CommandId"]

    # poll

    for _ in range(timeout_s):

        out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=instance_id)

        if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):

            code = int(out.get("ResponseCode", 1))

            return code, out.get("StandardOutputContent",""), out.get("StandardErrorContent","")

        time.sleep(1)

    return 1, "", "Timed out waiting for SSM command"

def http_status_via_ssm(instance_id, url):

    # Get only HTTP status and small body

    shell = f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}" || true'

    code, out, err = ssm_run(instance_id, shell, timeout_s=90)

    if code != 0:

        return None, f"curl failed: {err or out}"

    status = None

    body = out

    if "HTTP_STATUS:" in out:

        parts = out.rsplit("HTTP_STATUS:", 1)

        body = parts[0].strip()

        try: status = int(parts[1].strip())

        except: status = None

    return status, body

def main():

    tz = pytz.timezone(TZ_NAME)

    now = datetime.now(tz)

    print(f"Now: {now}  TZ={TZ_NAME}")

    for row in load_rows(CSV_PATH):

        app   = (row.get("app name") or row.get("appname") or "").strip()

        env   = (row.get("environment") or "").strip()

        if not app or env != TARGET_ENV: 

            continue

        start = parse_dt(row.get("start date"), tz)

        stop  = parse_dt(row.get("stop date"), tz)

        url   = (row.get("health url") or "").strip()

        cmd   = (row.get("command") or "").strip()

        iid   = (row.get("instanceid") or os.getenv("EC2_INSTANCE_ID") or "").strip()

        if not iid:

            print(f"[{app}] no InstanceId, skipping")

            continue

        if start <= now <= stop:

            # Inside window -> STOP (replace 'start' with 'stop')

            stop_cmd = cmd.replace("start", "stop")

            post_teams(f"üõë Patching started for **{app}** on {iid} ‚Äì running `{stop_cmd}`", "Info")

            rc, out, err = ssm_run(iid, stop_cmd)

            print(f"[{app}] stop rc={rc} out={out} err={err}")

            if rc != 0:

                post_teams(f"‚ùå Failed to stop {app}: {err or out}", "Alert")

        else:

            # Outside window -> START and Health

            post_teams(f"‚ñ∂Ô∏è Starting **{app}** on {iid} ‚Äì `{cmd}`", "Info")

            rc, out, err = ssm_run(iid, cmd)

            print(f"[{app}] start rc={rc} out={out} err={err}")

            if rc != 0:

                post_teams(f"‚ùå Failed to start {app}: {err or out}", "Alert")

                continue

            time.sleep(8)

            if url:

                status, body = http_status_via_ssm(iid, url)

                print(f"[{app}] health {status}")

                if status == 200:

                    post_teams(f"‚úÖ {app} healthy after patching", "Info")

                else:

                    post_teams(f"‚ùå {app} NOT healthy after patching (status {status})", "Alert")

if __name__ == "__main__":

    main()
 
