name: Patching Control (SSM) + Teams

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"  # every 5 minutes

jobs:
  patching-check:
    runs-on: ubuntu-latest

    env:
      CSV_PATH: schedule.csv
      TARGET_ENV: Production
      TZ: Asia/Kolkata
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 requests pandas openpyxl pytz

      - name: Run patching workflow
        run: |
          python <<'PY'
          import os, re, time, pandas as pd, requests, boto3, pytz
          from datetime import datetime

          # ===== Env variables =====
          CSV_PATH = os.getenv("CSV_PATH", "schedule.csv")
          TEAMS_URL = os.getenv("TEAMS_WEBHOOK_URL")
          TARGET_ENV = os.getenv("TARGET_ENV")
          TZ = pytz.timezone(os.getenv("TZ", "Asia/Kolkata"))
          AWS_REGION = os.getenv("AWS_REGION")
          FALLBACK_IID = os.getenv("EC2_INSTANCE_ID")
          ssm = boto3.client("ssm", region_name=AWS_REGION)

          def post_teams(msg, level="Info"):
              if not TEAMS_URL: return
              payload = {
                  "@type": "MessageCard",
                  "@context": "http://schema.org/extensions",
                  "themeColor": "0076D7" if level=="Info" else "FF0000",
                  "summary": f"{level}: {msg}",
                  "sections": [{"activityTitle": f"**{level}**", "text": msg}],
              }
              try: requests.post(TEAMS_URL, json=payload, timeout=10)
              except: print(f"[teams] failed: {msg}")

          def normalize_cols(df):
              df.columns = [c.strip().lower().replace(" ", "_") for c in df.columns]
              return df

          def parse_dt(s):
              for fmt in ("%d-%m-%Y %H:%M:%S","%d-%m-%Y %H:%M","%Y-%m-%d %H:%M:%S"):
                  try: return TZ.localize(datetime.strptime(s.strip(), fmt))
                  except: continue
              raise ValueError(f"Bad date: {s}")

          def ssm_run(iid, cmd, timeout=180):
              try:
                  resp = ssm.send_command(
                      InstanceIds=[iid],
                      DocumentName="AWS-RunShellScript",
                      Parameters={"commands":[cmd]},
                      CloudWatchOutputConfig={"CloudWatchOutputEnabled": False}
                  )
                  cmd_id = resp["Command"]["CommandId"]
                  for _ in range(timeout):
                      out = ssm.get_command_invocation(CommandId=cmd_id, InstanceId=iid)
                      if out["Status"] in ("Success","Failed","Cancelled","TimedOut"):
                          return int(out.get("ResponseCode",1)), out.get("StandardOutputContent",""), out.get("StandardErrorContent","")
                      time.sleep(1)
                  return 1, "", "Timeout waiting for SSM command"
              except Exception as e:
                  return 1, "", f"SSM error: {e}"

          df = pd.read_csv(CSV_PATH)
          df = normalize_cols(df)

          # Step 1: send schedule to Teams
          post_teams("üìã Patching Schedule:\n" + df.to_string(index=False))

          now = datetime.now(TZ)
          any_action = False

          for idx, row in df.iterrows():
              try:
                  env = row.get("environment", "").strip()
                  if env != TARGET_ENV: continue

                  app = row.get("app_name") or row.get("app")
                  iid = row.get("instanceid") or FALLBACK_IID
                  cmd = row.get("command") or row.get("cmd")
                  url = row.get("health_url") or row.get("url")
                  start = parse_dt(row.get("start_date") or row.get("start"))
                  stop  = parse_dt(row.get("stop_date") or row.get("stop"))

                  # Auto-approve
                  if str(row.get("approval_status","")).lower() != "approved":
                      df.at[idx,"approval_status"] = "approved"
                      post_teams(f"‚úÖ Patching scheduled & auto-approved for {app}")

                  any_action = True

                  # Inside patch window ‚Üí stop cmd
                  if start <= now <= stop:
                      stop_cmd = cmd.replace("start","stop")
                      post_teams(f"üõë Patching active for {app} ({iid}) -> {stop_cmd}")
                      rc, out, err = ssm_run(iid, stop_cmd)
                      print(f"[{app}] stop rc={rc}\nstdout={out}\nstderr={err}")
                  else:
                      # Outside window ‚Üí start + health
                      post_teams(f"‚ñ∂Ô∏è Starting {app} ({iid}) -> {cmd}")
                      rc, out, err = ssm_run(iid, cmd)
                      print(f"[{app}] start rc={rc}\nstdout={out}\nstderr={err}")
                      time.sleep(5)
                      if url:
                          status, _ = ssm_run(iid, f'curl -sS -m 8 -w "\\nHTTP_STATUS:%{{http_code}}" "{url}"')
                          if status==0: post_teams(f"‚úÖ {app} healthy after patching")
                          else: post_teams(f"‚ùå {app} unhealthy after patching", "Alert")
              except Exception as e:
                  post_teams(f"‚ùå Error processing row {idx}: {e}", "Alert")

          # Save updated approvals
          df.to_csv(CSV_PATH, index=False)
          PY
